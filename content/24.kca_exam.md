Title: Prepare for the Kyverno Certified Associate (KCA) exam
Date: 2025-12-18
Category: Knowledge Base
Tags: kyverno, certification, linux-foundation, kca

![alt text](images/2025/12/18.png)

# Kyverno Overview: The "Kubernetes Native" Policy Engine

If you are preparing for the KCA (Kyverno Certified Associate) exam or just getting started with policy-as-code, you need to grasp the core concepts before diving into the syntax. Here is the high-level overview.

### 1. What is Kyverno? (Keyword: Kubernetes Native)
Unlike OPA Gatekeeper (which requires learning the complex Rego language), Kyverno is Kubernetes Native.

- The Key Differentiator: Policies are written in standard YAML. If you can read Kubernetes manifests (Deployment, Service, etc.), you can understand Kyverno policies immediately.
- Role: It acts as a "Gatekeeper" (Admission Controller) sitting right at the API Server door.

### 2. Core Logic (How it works)

When you execute kubectl apply -f pod.yaml, the flow is as follows:

- The request hits the API Server.
- Kyverno (acting as a Webhook) intercepts the request.
- It checks if the request matches any defined Policy.
- If matched, it executes one of the 4 main actions (this is the backbone of the KCA exam):

### 3. Key Capabilities (The 4 Pillars)

1. Validation (Most Common)

- Goal: "Allowed" or "Denied".
- Example: A Pod must have the label team: dev. If missing -> Block (Enforce) or Warn (Audit).

2. Mutation (Modify)

- Goal: Modify the YAML content before it is persisted to the database (etcd).
- Example: A user creates a Pod but forgets the imagePullPolicy. Kyverno automatically injects imagePullPolicy: Always.

3. Generation (Create New) - The "Killer Feature"

- Goal: Automatically generate additional resources based on a trigger.
- Example: When a new Namespace is created -> Kyverno automatically generates a default NetworkPolicy and ResourceQuota inside that Namespace.

4. Verify Images (Supply Chain Security)

- Goal: Check container image signatures.
- Example: Only allow images signed by the company's private key (integrates with Cosign/Sigstore)

### 4. Anatomy of a Policy

A basic Policy file follows this nested structure:

- Policy / ClusterPolicy:
```
Policy: Scoped to a specific Namespace.
ClusterPolicy: Applied to the entire cluster (Global).
```
- Rules: A Policy can contain multiple Rules
- Match / Exclude: Selects the resources to target (e.g., match all Pods, exclude Pods in kube-system).
- Action: What to do (validate, mutate, generate, verifyImages).

Quick YAML Structure Example:

```yaml
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: require-labels
spec:
  validationFailureAction: Enforce # Enforce (Block) or Audit (Log report)
  rules:
  - name: check-team-label
    match:
      resources:
        kinds:
        - Pod # Apply to Pods
    validate: # Validation Action
      message: "The 'team' label is required!"
      pattern:
        metadata:
          labels:
            team: "?*" # Check for existence
```

### 5. Exam Tips (Must Know)

Models: 

- Audit: Violations are allowed but logged in a PolicyReport. This is the safe default for Production to avoid breaking existing workflows.
- Enforce: Violations are blocked immediately (Deny).

JMESPath: Kyverno uses JMESPath for logic processing (handling if/else, contains, sum, etc.). Expect questions on filtering JSON data using JMESPath.

Auto-gen Rules: If you write a rule for Pod, Kyverno is smart enough to automatically generate rules for Deployment, StatefulSet, DaemonSet, etc. (unless you explicitly disable this feature).

Summary: Kyverno is an Admission Controller that uses YAML to Validate, Mutate, Generate resources, and Verify Images.