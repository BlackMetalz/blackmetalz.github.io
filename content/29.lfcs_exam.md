Title: [WIP] Linux Foundation Certified System Administrator (LFCS)
Date: 2025-12-31
Category: Knowledge Base
Tags: linux, certification


# Sections
- IO Redirection
- LVM

---

# IO Redirection

I think this is the most command I often used but never understand correctly, LOL. Yes, it is `2>&1`. But no more, today I swear I will remember and understand it! So let's take an example:
```bash
./script.sh > output.txt 2>&1
```

`./script.sh` will give to output
```bash
bob@ubuntu-host ~ ✖ ./script.sh 
/home/bob
./script.sh: line 2: lss: command not found
```

This part `> output.txt`: can be understood as redirect `stdout` (file descriptor 1) into file `output.txt`

This part `2>&1`: can be understood as redirect `stderr` (file descriptor 2) into file descriptor 1 pointed to. At this time file descriptor 1 already getting redirected into `output.txt`, so file descriptor 2 will go together xD 

And order is important

- It must be `> output.txt 2>&1`. Example:
```bash
bob@ubuntu-host ~ ➜  ./script.sh > output.txt 2>&1

bob@ubuntu-host ~ ✖ cat output.txt 
/home/bob
./script.sh: line 2: lss: command not found
```
- If `2>&1 > asd.txt`: only stdout getting into file. Example:
```bash
bob@ubuntu-host ~ ➜  ./script.sh 2>&1 > asd.txt
./script.sh: line 2: lss: command not found

bob@ubuntu-host ~ ✖ cat asd.txt 
/home/bob
```

Shell Redirection Cheat sheet:

- **`> file 2>&1`** Redirects both **stdout** and **stderr** to a file (the most standard/compatible method).
- **`&> file`** Shorthand for the above (supported in **bash** and **zsh**).
- **`>> file 2>&1`** **Appends** both **stdout** and **stderr** to a file.
- **`2>/dev/null`** Discards error messages (**stderr**); keeps only the standard output.

Redirection Use Cases:

- **`./script.sh > output.txt 2>&1`** Captures everything (**logs + errors**) into a single file.
- **`./script.sh > /dev/null 2>&1`** **Total silence**; suppresses all output and error messages completely.
- **`./script.sh 2> error.txt`** Redirects **only the errors** to a file; the normal logs will still show up on your terminal.

And the last, we had fd2/fd1 so what is fd0? It is standard input (stdin). Example: `mysql database_name < backup.sql`

---

# LVM (Logical Volume Manager)

To be honest, I rarely use LVM in OpenStack environments because my managed platforms are Elasticsearch, Kafka, which all support multiple disks. You know in the OpenStack environment, 1 volume 10 GB has 200 IOPS, but 2 volumes 5 GB have 400 IOPS. Same size but double IOPS, that is why I used multi disk.

But when it comes to MongoDB, it needs to use LVM since MongoDB doesn't support multi-disk. But It was a lab setup without document write back, so it is like fire and forget mode -.-

So that is a story for simple knowledge everyone remembers and understands, but not me xD. So this is "day one" instead of "one day"!

### Prerequisite
- Ubuntu 22/24 and package `lvm2` installed
- [Kodekloud Lab - Manage LVM](https://learn.kodekloud.com/user/courses/labs-linux-foundation-certified-system-administrator-lfcs/)

### Physical Volume (PV) 
They are physical volumes (P) like `/dev/sdb` or disk partition `/dev/sda1` you want to put it in LVM system.

- Init PV: `pvcreate /dev/sdb` (turn `/dev/sdb` into material for LVM)
- Check PV: `pvdisplay` or `pvs`

Example:
```bash
### PV Create
root@caleston-lp10 ~ ➜  pvcreate /dev/vdb /dev/vdc
  Physical volume "/dev/vdb" successfully created.
  Physical volume "/dev/vdc" successfully created.
### PV Display
root@caleston-lp10 ~ ➜  pvdisplay 
  "/dev/vdb" is a new physical volume of "1.00 GiB"
  --- NEW Physical volume ---
  PV Name               /dev/vdb
  VG Name               
  PV Size               1.00 GiB
  Allocatable           NO
  PE Size               0   
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               aaPJMu-vtoq-yU0a-xsg4-LwPV-IYE4-TRb1sF
   
  "/dev/vdc" is a new physical volume of "1.00 GiB"
  --- NEW Physical volume ---
  PV Name               /dev/vdc
  VG Name               
  PV Size               1.00 GiB
  Allocatable           NO
  PE Size               0   
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               y1Mod8-Li2M-i7NR-Yqg4-mjZt-gEos-M4EwSe
   

root@caleston-lp10 ~ ➜  pvs
  PV         VG Fmt  Attr PSize PFree
  /dev/vdb      lvm2 ---  1.00g 1.00g
  /dev/vdc      lvm2 ---  1.00g 1.00g
```

- Remove PV from LVM: `pvremove /dev/vdc`
```bash
root@caleston-lp10 ~ ➜  pvremove /dev/vdc
  Labels on physical volume "/dev/vdc" successfully wiped.

root@caleston-lp10 ~ ➜  pvs
  PV         VG Fmt  Attr PSize PFree
  /dev/vdb      lvm2 ---  1.00g 1.00g
```

### Volume Group (VG)
Group of physical volumes (V). You group all the PVs together into one large group called VGs.

VG named by you, ex: VG named "my-vg"

Command to create VG: `pvcreate volume-name pv-here`
```bash
root@caleston-lp10 ~ ➜  vgcreate volume1 /dev/vdb
  Volume group "volume1" successfully created
```

Command to check VG: `vgdisplay` or `vgs`

Extend VG by adding PV: `vgextend volume-name pv-here`
```bash
root@caleston-lp10 ~ ➜  vgextend volume1 /dev/vdc
  Physical volume "/dev/vdc" successfully created.
  Volume group "volume1" successfully extended

# Before add pv /dev/vdc to vg volume1, it was 1 PV and Vsize 1.00g
root@caleston-lp10 ~ ➜  vgs
  VG      #PV #LV #SN Attr   VSize VFree
  volume1   2   0   0 wz--n- 1.99g 1.99g
```

Remove PV from VG: `vgreduce volume-name pv-here`
```bash
root@caleston-lp10 ~ ➜  vgreduce volume1 /dev/vdc
  Removed "/dev/vdc" from volume group "volume1"

root@caleston-lp10 ~ ➜  vgs
  VG      #PV #LV #SN Attr   VSize    VFree   
  volume1   1   0   0 wz--n- 1020.00m 1020.00m
```

### Logical Volume (LV)
from big VG, you divide it into smaller or all to use called LV (L).

Relationship: 1 VG can divide into 1 or more LV
 
Init command: Create LV named `smalldata`, size 0.5 G from VG volume1.

```bash
root@caleston-lp10 ~ ✖ lvcreate -L 0.5G -n smalldata volume1
  Logical volume "smalldata" created.
root@caleston-lp10 ~ ➜  lvs
  LV        VG      Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  smalldata volume1 -wi-a----- 512.00m                                               
```

Display LV command: `lvs` or `lvdisplay`

Resize LV to `752 MB`: param can be `-L` or `--size` xD
```bash
root@caleston-lp10 ~ ✖ lvresize -L 752M volume1/smalldata
  Size of logical volume volume1/smalldata changed from 512.00 MiB (128 extents) to 752.00 MiB (188 extents).
  Logical volume volume1/smalldata successfully resized.

root@caleston-lp10 ~ ➜  lvresize --size 753M volume1/smalldata
  Rounding size to boundary between physical extents: 756.00 MiB.
  Size of logical volume volume1/smalldata changed from 752.00 MiB (188 extents) to 756.00 MiB (189 extents).
  Logical volume volume1/smalldata successfully resized.
```

Destroy/Remove LV from VG
```bash
root@caleston-lp10 ~ ➜  lvremove volume1/smalldata
Do you really want to remove and DISCARD active logical volume volume1/smalldata? [y/n]: y
  Logical volume "smalldata" successfully removed
  root@caleston-lp10 ~ ➜  vgs
  VG      #PV #LV #SN Attr   VSize    VFree   
  volume1   1   0   0 wz--n- 1020.00m 1020.00m

root@caleston-lp10 ~ ➜  lvs
```

### Create filesystem from LV

XFS or EXT4, your choice

Command: `mkfs.xfs /dev/volume1/smalldata`
```bash
mkfs.xfs /dev/volume1/smalldata
```